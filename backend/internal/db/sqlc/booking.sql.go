// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.29.0
// source: booking.sql

package db

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const countActiveBookingByTrain = `-- name: CountActiveBookingByTrain :one
SELECT COUNT(*)
FROM booking
WHERE trainId = $1
     AND travelDate = $2
     AND status = 'PENDING'
`

type CountActiveBookingByTrainParams struct {
	Trainid    pgtype.Int4 `json:"trainid"`
	Traveldate pgtype.Date `json:"traveldate"`
}

func (q *Queries) CountActiveBookingByTrain(ctx context.Context, arg CountActiveBookingByTrainParams) (int64, error) {
	row := q.db.QueryRow(ctx, countActiveBookingByTrain, arg.Trainid, arg.Traveldate)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const createBooking = `-- name: CreateBooking :one
INSERT INTO booking (userId, trainId, travelDate, status, holdToken)
VALUES ($1, $2, $3, 'PENDING', $4)
RETURNING id, userid, trainid, traveldate, status, holdtoken, paymentid, createdat
`

type CreateBookingParams struct {
	Userid     pgtype.UUID `json:"userid"`
	Trainid    pgtype.Int4 `json:"trainid"`
	Traveldate pgtype.Date `json:"traveldate"`
	Holdtoken  pgtype.Text `json:"holdtoken"`
}

func (q *Queries) CreateBooking(ctx context.Context, arg CreateBookingParams) (Booking, error) {
	row := q.db.QueryRow(ctx, createBooking,
		arg.Userid,
		arg.Trainid,
		arg.Traveldate,
		arg.Holdtoken,
	)
	var i Booking
	err := row.Scan(
		&i.ID,
		&i.Userid,
		&i.Trainid,
		&i.Traveldate,
		&i.Status,
		&i.Holdtoken,
		&i.Paymentid,
		&i.Createdat,
	)
	return i, err
}

const createBookingItem = `-- name: CreateBookingItem :one
INSERT INTO bookingItem (bookingId, seatId, trainScheduleId)
VALUES ($1, $2, $3)
RETURNING id, bookingid, seatid, trainscheduleid
`

type CreateBookingItemParams struct {
	Bookingid       pgtype.Int4 `json:"bookingid"`
	Seatid          pgtype.Int4 `json:"seatid"`
	Trainscheduleid pgtype.Int4 `json:"trainscheduleid"`
}

func (q *Queries) CreateBookingItem(ctx context.Context, arg CreateBookingItemParams) (Bookingitem, error) {
	row := q.db.QueryRow(ctx, createBookingItem, arg.Bookingid, arg.Seatid, arg.Trainscheduleid)
	var i Bookingitem
	err := row.Scan(
		&i.ID,
		&i.Bookingid,
		&i.Seatid,
		&i.Trainscheduleid,
	)
	return i, err
}

const currentAvailabeSeats = `-- name: CurrentAvailabeSeats :many
SELECT s.id
FROM seat s WHERE
seat.id = ANY($1 :: int[])
 AND NOT EXISTS (
   SELECT 1 FROM
   bookingItem bi
   JOIN booking b ON bi.bookingId = b.id
   WHERE bi.seatId = s.id
   AND b.status  IN('PENDING','CONFIRMED')
   AND b.trainId = $2
   AND b.travelDate = $3
 )
`

type CurrentAvailabeSeatsParams struct {
	Column1    []int32     `json:"column_1"`
	Trainid    pgtype.Int4 `json:"trainid"`
	Traveldate pgtype.Date `json:"traveldate"`
}

func (q *Queries) CurrentAvailabeSeats(ctx context.Context, arg CurrentAvailabeSeatsParams) ([]int32, error) {
	rows, err := q.db.Query(ctx, currentAvailabeSeats, arg.Column1, arg.Trainid, arg.Traveldate)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []int32{}
	for rows.Next() {
		var id int32
		if err := rows.Scan(&id); err != nil {
			return nil, err
		}
		items = append(items, id)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const deleteBookingItemsByBooking = `-- name: DeleteBookingItemsByBooking :exec
DELETE FROM bookingItem WHERE bookingId = $1
`

func (q *Queries) DeleteBookingItemsByBooking(ctx context.Context, bookingid pgtype.Int4) error {
	_, err := q.db.Exec(ctx, deleteBookingItemsByBooking, bookingid)
	return err
}

const expireOldBooking = `-- name: ExpireOldBooking :exec
UPDATE booking
SET status='EXPIRED'
 WHERE status='PENDING'
   AND createdat > now() - INTERVAL '10 minutes'
`

func (q *Queries) ExpireOldBooking(ctx context.Context) error {
	_, err := q.db.Exec(ctx, expireOldBooking)
	return err
}

const getActiveBookingByUser = `-- name: GetActiveBookingByUser :one
SELECT id, userid, trainid, traveldate, status, holdtoken, paymentid, createdat
FROM booking
WHERE userid = $1
  AND status = 'PENDING'
  AND createdat > now() - INTERVAL '10 minutes'
LIMIT 1
`

func (q *Queries) GetActiveBookingByUser(ctx context.Context, userid pgtype.UUID) (Booking, error) {
	row := q.db.QueryRow(ctx, getActiveBookingByUser, userid)
	var i Booking
	err := row.Scan(
		&i.ID,
		&i.Userid,
		&i.Trainid,
		&i.Traveldate,
		&i.Status,
		&i.Holdtoken,
		&i.Paymentid,
		&i.Createdat,
	)
	return i, err
}

const getBookedSeats = `-- name: GetBookedSeats :many
SELECT bi.seatId
FROM bookingItem bi
JOIN booking b on bi.bookingId = b.id
 WHERE b.trainId = $1 AND
  b.travelDate = $2
  AND b.status IN('PENDING','CONFIRMED')
`

type GetBookedSeatsParams struct {
	Trainid    pgtype.Int4 `json:"trainid"`
	Traveldate pgtype.Date `json:"traveldate"`
}

func (q *Queries) GetBookedSeats(ctx context.Context, arg GetBookedSeatsParams) ([]pgtype.Int4, error) {
	rows, err := q.db.Query(ctx, getBookedSeats, arg.Trainid, arg.Traveldate)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []pgtype.Int4{}
	for rows.Next() {
		var seatid pgtype.Int4
		if err := rows.Scan(&seatid); err != nil {
			return nil, err
		}
		items = append(items, seatid)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getBookingByHoldToken = `-- name: GetBookingByHoldToken :one
SELECT id, userid, trainid, traveldate, status, holdtoken, paymentid, createdat FROM booking WHERE holdToken = $1
`

func (q *Queries) GetBookingByHoldToken(ctx context.Context, holdtoken pgtype.Text) (Booking, error) {
	row := q.db.QueryRow(ctx, getBookingByHoldToken, holdtoken)
	var i Booking
	err := row.Scan(
		&i.ID,
		&i.Userid,
		&i.Trainid,
		&i.Traveldate,
		&i.Status,
		&i.Holdtoken,
		&i.Paymentid,
		&i.Createdat,
	)
	return i, err
}

const getBookingItemsByBooking = `-- name: GetBookingItemsByBooking :many
SELECT seatId FROM bookingItem WHERE bookingId = $1
`

func (q *Queries) GetBookingItemsByBooking(ctx context.Context, bookingid pgtype.Int4) ([]pgtype.Int4, error) {
	rows, err := q.db.Query(ctx, getBookingItemsByBooking, bookingid)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []pgtype.Int4{}
	for rows.Next() {
		var seatid pgtype.Int4
		if err := rows.Scan(&seatid); err != nil {
			return nil, err
		}
		items = append(items, seatid)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getBookingbyUserId = `-- name: GetBookingbyUserId :many
SELECT bi.id, bi.bookingid, bi.seatid, bi.trainscheduleid , b.id, b.userid, b.trainid, b.traveldate, b.status, b.holdtoken, b.paymentid, b.createdat
FROM booking b 
JOIN bookingItem bi 
ON b.id = bi.bookingId
WHERE b.userId = $1
`

type GetBookingbyUserIdRow struct {
	ID              int32            `json:"id"`
	Bookingid       pgtype.Int4      `json:"bookingid"`
	Seatid          pgtype.Int4      `json:"seatid"`
	Trainscheduleid pgtype.Int4      `json:"trainscheduleid"`
	ID_2            int32            `json:"id_2"`
	Userid          pgtype.UUID      `json:"userid"`
	Trainid         pgtype.Int4      `json:"trainid"`
	Traveldate      pgtype.Date      `json:"traveldate"`
	Status          BookingStatus    `json:"status"`
	Holdtoken       pgtype.Text      `json:"holdtoken"`
	Paymentid       pgtype.Int4      `json:"paymentid"`
	Createdat       pgtype.Timestamp `json:"createdat"`
}

func (q *Queries) GetBookingbyUserId(ctx context.Context, userid pgtype.UUID) ([]GetBookingbyUserIdRow, error) {
	rows, err := q.db.Query(ctx, getBookingbyUserId, userid)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetBookingbyUserIdRow{}
	for rows.Next() {
		var i GetBookingbyUserIdRow
		if err := rows.Scan(
			&i.ID,
			&i.Bookingid,
			&i.Seatid,
			&i.Trainscheduleid,
			&i.ID_2,
			&i.Userid,
			&i.Trainid,
			&i.Traveldate,
			&i.Status,
			&i.Holdtoken,
			&i.Paymentid,
			&i.Createdat,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateBookingStatus = `-- name: UpdateBookingStatus :exec
UPDATE booking
SET status = $2
WHERE id = $1
`

type UpdateBookingStatusParams struct {
	ID     int32         `json:"id"`
	Status BookingStatus `json:"status"`
}

func (q *Queries) UpdateBookingStatus(ctx context.Context, arg UpdateBookingStatusParams) error {
	_, err := q.db.Exec(ctx, updateBookingStatus, arg.ID, arg.Status)
	return err
}
