// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.29.0
// source: train.sql

package db

import (
	"context"
	"time"

	"github.com/jackc/pgx/v5/pgtype"
)

const createCoach = `-- name: CreateCoach :one
INSERT into coach (trainId,coachtype,coachNumber) VALUES ($1 , $2 , $3) RETURNING id, trainid, coachtype, coachnumber
`

type CreateCoachParams struct {
	Trainid     pgtype.Int4 `json:"trainid"`
	Coachtype   CoachType   `json:"coachtype"`
	Coachnumber int32       `json:"coachnumber"`
}

func (q *Queries) CreateCoach(ctx context.Context, arg CreateCoachParams) (Coach, error) {
	row := q.db.QueryRow(ctx, createCoach, arg.Trainid, arg.Coachtype, arg.Coachnumber)
	var i Coach
	err := row.Scan(
		&i.ID,
		&i.Trainid,
		&i.Coachtype,
		&i.Coachnumber,
	)
	return i, err
}

const createSeat = `-- name: CreateSeat :one
INSERT into seat (coachId,seatno,berth) VALUES ($1 , $2 , $3) RETURNING id, coachid, seatno, berth
`

type CreateSeatParams struct {
	Coachid pgtype.Int4 `json:"coachid"`
	Seatno  int32       `json:"seatno"`
	Berth   BerthType   `json:"berth"`
}

func (q *Queries) CreateSeat(ctx context.Context, arg CreateSeatParams) (Seat, error) {
	row := q.db.QueryRow(ctx, createSeat, arg.Coachid, arg.Seatno, arg.Berth)
	var i Seat
	err := row.Scan(
		&i.ID,
		&i.Coachid,
		&i.Seatno,
		&i.Berth,
	)
	return i, err
}

const createTrain = `-- name: CreateTrain :one
INSERT into train(trainNumber,trainName,source,destination )
VALUES ( $1 ,$2 ,$3,$4) 
RETURNING id, trainnumber, trainname, source, destination
`

type CreateTrainParams struct {
	Trainnumber int32  `json:"trainnumber"`
	Trainname   string `json:"trainname"`
	Source      string `json:"source"`
	Destination string `json:"destination"`
}

func (q *Queries) CreateTrain(ctx context.Context, arg CreateTrainParams) (Train, error) {
	row := q.db.QueryRow(ctx, createTrain,
		arg.Trainnumber,
		arg.Trainname,
		arg.Source,
		arg.Destination,
	)
	var i Train
	err := row.Scan(
		&i.ID,
		&i.Trainnumber,
		&i.Trainname,
		&i.Source,
		&i.Destination,
	)
	return i, err
}

const createTrainSchedule = `-- name: CreateTrainSchedule :one
INSERT into trainSchedule(trainId,day,arrivalTime,departureTime)
VALUES ( $1 ,$2 ,$3,$4) 
RETURNING id, trainid, day, arrivaltime, departuretime
`

type CreateTrainScheduleParams struct {
	Trainid       pgtype.Int4 `json:"trainid"`
	Day           DayOfWeek   `json:"day"`
	Arrivaltime   time.Time   `json:"arrivaltime"`
	Departuretime time.Time   `json:"departuretime"`
}

func (q *Queries) CreateTrainSchedule(ctx context.Context, arg CreateTrainScheduleParams) (Trainschedule, error) {
	row := q.db.QueryRow(ctx, createTrainSchedule,
		arg.Trainid,
		arg.Day,
		arg.Arrivaltime,
		arg.Departuretime,
	)
	var i Trainschedule
	err := row.Scan(
		&i.ID,
		&i.Trainid,
		&i.Day,
		&i.Arrivaltime,
		&i.Departuretime,
	)
	return i, err
}

const getAvailableSeats = `-- name: GetAvailableSeats :many
CREATE OR REPLACE FUNCTION get_avaliable_seats(
    p_train_id INTEGER,
    p_travel_day TIME
)
RETURNS TABLE (
    coach_type TEXT,
    total_seats BIGINT,
    booked_seats BIGINT,
    available_seats BIGINT
)
LANGUAGE plpgsql
AS $$ 
BEGIN 
    RETURN QUERY 
    SELECT c.coach_type ,
           count(s.id) ::BIGINT as total_seats
           count(bi.seatId) :: BIGINT as booked_seats
          (count(s.id)- count(bi.seatId)) :: BIGINT as available_seats
    FROM train t 
    JOIN coach c on t.id = c.trainId
    JOIN seat s on  c.id = s.coachId
    LEFT JOIN (
        SELECT DISTINCT bi.seatId
        FROM booking b
        JOIN bookingItem bi ON b.id = bi.bookingId
        WHERE b.trainId = p_train_id
          AND b.travelDate = p_travel_date
          AND b.status IN ('CONFIRMED', 'PENDING')
    ) bi ON s.id = bi.seatId
    WHERE t.id = p_train_id
    GROUP BY c.coachtype
    ORDER BY c.coachtype;
END;
$$
`

type GetAvailableSeatsRow struct {
}

func (q *Queries) GetAvailableSeats(ctx context.Context) ([]GetAvailableSeatsRow, error) {
	rows, err := q.db.Query(ctx, getAvailableSeats)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetAvailableSeatsRow{}
	for rows.Next() {
		var i GetAvailableSeatsRow
		if err := rows.Scan(); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getAvailableSeatsExecute = `-- name: GetAvailableSeatsExecute :many
SELECT  FROM get_available_seats($1, $2)
`

type GetAvailableSeatsExecuteParams struct {
	GetAvailableSeats   interface{} `json:"get_available_seats"`
	GetAvailableSeats_2 interface{} `json:"get_available_seats_2"`
}

type GetAvailableSeatsExecuteRow struct {
}

func (q *Queries) GetAvailableSeatsExecute(ctx context.Context, arg GetAvailableSeatsExecuteParams) ([]GetAvailableSeatsExecuteRow, error) {
	rows, err := q.db.Query(ctx, getAvailableSeatsExecute, arg.GetAvailableSeats, arg.GetAvailableSeats_2)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetAvailableSeatsExecuteRow{}
	for rows.Next() {
		var i GetAvailableSeatsExecuteRow
		if err := rows.Scan(); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getCoachesByTrain = `-- name: GetCoachesByTrain :many
SELECT id, trainid, coachtype, coachnumber FROM coach WHERE trainId = $1
`

func (q *Queries) GetCoachesByTrain(ctx context.Context, trainid pgtype.Int4) ([]Coach, error) {
	rows, err := q.db.Query(ctx, getCoachesByTrain, trainid)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Coach{}
	for rows.Next() {
		var i Coach
		if err := rows.Scan(
			&i.ID,
			&i.Trainid,
			&i.Coachtype,
			&i.Coachnumber,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getSeatsByCoach = `-- name: GetSeatsByCoach :many
SELECT id, coachid, seatno, berth FROM seat WHERE coachId = $1
`

func (q *Queries) GetSeatsByCoach(ctx context.Context, coachid pgtype.Int4) ([]Seat, error) {
	rows, err := q.db.Query(ctx, getSeatsByCoach, coachid)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Seat{}
	for rows.Next() {
		var i Seat
		if err := rows.Scan(
			&i.ID,
			&i.Coachid,
			&i.Seatno,
			&i.Berth,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getSeatsByTrain = `-- name: GetSeatsByTrain :many
SELECT s.id, s.coachid, s.seatno, s.berth
FROM seat s 
JOIN coach c ON s.coachId = c.id
WHERE c.trainId = $1
`

func (q *Queries) GetSeatsByTrain(ctx context.Context, trainid pgtype.Int4) ([]Seat, error) {
	rows, err := q.db.Query(ctx, getSeatsByTrain, trainid)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Seat{}
	for rows.Next() {
		var i Seat
		if err := rows.Scan(
			&i.ID,
			&i.Coachid,
			&i.Seatno,
			&i.Berth,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getTrainById = `-- name: GetTrainById :one
SELECT id, trainnumber, trainname, source, destination FROM train
WHERE id = $1
`

func (q *Queries) GetTrainById(ctx context.Context, id int32) (Train, error) {
	row := q.db.QueryRow(ctx, getTrainById, id)
	var i Train
	err := row.Scan(
		&i.ID,
		&i.Trainnumber,
		&i.Trainname,
		&i.Source,
		&i.Destination,
	)
	return i, err
}

const getTrainScheduleByDay = `-- name: GetTrainScheduleByDay :one
SELECT id, trainid, day, arrivaltime, departuretime FROM trainSchedule
WHERE trainId = $1 AND day = $2
`

type GetTrainScheduleByDayParams struct {
	Trainid pgtype.Int4 `json:"trainid"`
	Day     DayOfWeek   `json:"day"`
}

func (q *Queries) GetTrainScheduleByDay(ctx context.Context, arg GetTrainScheduleByDayParams) (Trainschedule, error) {
	row := q.db.QueryRow(ctx, getTrainScheduleByDay, arg.Trainid, arg.Day)
	var i Trainschedule
	err := row.Scan(
		&i.ID,
		&i.Trainid,
		&i.Day,
		&i.Arrivaltime,
		&i.Departuretime,
	)
	return i, err
}
