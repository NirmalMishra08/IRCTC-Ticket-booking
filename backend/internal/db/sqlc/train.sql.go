// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.29.0
// source: train.sql

package db

import (
	"context"
	"time"

	"github.com/jackc/pgx/v5/pgtype"
)

const createCoach = `-- name: CreateCoach :one
INSERT into coach (trainId,coachtype,coachNumber) VALUES ($1 , $2 , $3) RETURNING id, trainid, coachtype, coachnumber
`

type CreateCoachParams struct {
	Trainid     pgtype.Int4 `json:"trainid"`
	Coachtype   CoachType   `json:"coachtype"`
	Coachnumber int32       `json:"coachnumber"`
}

func (q *Queries) CreateCoach(ctx context.Context, arg CreateCoachParams) (Coach, error) {
	row := q.db.QueryRow(ctx, createCoach, arg.Trainid, arg.Coachtype, arg.Coachnumber)
	var i Coach
	err := row.Scan(
		&i.ID,
		&i.Trainid,
		&i.Coachtype,
		&i.Coachnumber,
	)
	return i, err
}

const createSeat = `-- name: CreateSeat :one
INSERT into seat (coachId,seatno,berth) VALUES ($1 , $2 , $3) RETURNING id, coachid, seatno, berth
`

type CreateSeatParams struct {
	Coachid pgtype.Int4 `json:"coachid"`
	Seatno  int32       `json:"seatno"`
	Berth   BerthType   `json:"berth"`
}

func (q *Queries) CreateSeat(ctx context.Context, arg CreateSeatParams) (Seat, error) {
	row := q.db.QueryRow(ctx, createSeat, arg.Coachid, arg.Seatno, arg.Berth)
	var i Seat
	err := row.Scan(
		&i.ID,
		&i.Coachid,
		&i.Seatno,
		&i.Berth,
	)
	return i, err
}

const createTrain = `-- name: CreateTrain :one
INSERT into train(trainNumber,trainName,source,destination )
VALUES ( $1 ,$2 ,$3,$4) 
RETURNING id, trainnumber, trainname, source, destination
`

type CreateTrainParams struct {
	Trainnumber int32  `json:"trainnumber"`
	Trainname   string `json:"trainname"`
	Source      string `json:"source"`
	Destination string `json:"destination"`
}

func (q *Queries) CreateTrain(ctx context.Context, arg CreateTrainParams) (Train, error) {
	row := q.db.QueryRow(ctx, createTrain,
		arg.Trainnumber,
		arg.Trainname,
		arg.Source,
		arg.Destination,
	)
	var i Train
	err := row.Scan(
		&i.ID,
		&i.Trainnumber,
		&i.Trainname,
		&i.Source,
		&i.Destination,
	)
	return i, err
}

const createTrainSchedule = `-- name: CreateTrainSchedule :one
INSERT into trainSchedule(trainId,day,arrivalTime,departureTime)
VALUES ( $1 ,$2 ,$3,$4) 
RETURNING id, trainid, day, arrivaltime, departuretime
`

type CreateTrainScheduleParams struct {
	Trainid       pgtype.Int4 `json:"trainid"`
	Day           DayOfWeek   `json:"day"`
	Arrivaltime   time.Time   `json:"arrivaltime"`
	Departuretime time.Time   `json:"departuretime"`
}

func (q *Queries) CreateTrainSchedule(ctx context.Context, arg CreateTrainScheduleParams) (Trainschedule, error) {
	row := q.db.QueryRow(ctx, createTrainSchedule,
		arg.Trainid,
		arg.Day,
		arg.Arrivaltime,
		arg.Departuretime,
	)
	var i Trainschedule
	err := row.Scan(
		&i.ID,
		&i.Trainid,
		&i.Day,
		&i.Arrivaltime,
		&i.Departuretime,
	)
	return i, err
}

const getAllTrain = `-- name: GetAllTrain :many
SELECT t.id, t.trainnumber, t.trainname, t.source, t.destination , ts.id, ts.trainid, ts.day, ts.arrivaltime, ts.departuretime
FROM train t
JOIN trainSchedule ts ON t.id = ts.trainid
`

type GetAllTrainRow struct {
	ID            int32       `json:"id"`
	Trainnumber   int32       `json:"trainnumber"`
	Trainname     string      `json:"trainname"`
	Source        string      `json:"source"`
	Destination   string      `json:"destination"`
	ID_2          int32       `json:"id_2"`
	Trainid       pgtype.Int4 `json:"trainid"`
	Day           DayOfWeek   `json:"day"`
	Arrivaltime   time.Time   `json:"arrivaltime"`
	Departuretime time.Time   `json:"departuretime"`
}

func (q *Queries) GetAllTrain(ctx context.Context) ([]GetAllTrainRow, error) {
	rows, err := q.db.Query(ctx, getAllTrain)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetAllTrainRow{}
	for rows.Next() {
		var i GetAllTrainRow
		if err := rows.Scan(
			&i.ID,
			&i.Trainnumber,
			&i.Trainname,
			&i.Source,
			&i.Destination,
			&i.ID_2,
			&i.Trainid,
			&i.Day,
			&i.Arrivaltime,
			&i.Departuretime,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getAvailableSeats = `-- name: GetAvailableSeats :many
CREATE  OR REPLACE FUNCTION get_available_seats(
    p_train_id INTEGER,
    p_travel_date DATE  -- Changed from TIME to DATE to match your schema
)
RETURNS TABLE (
    coach_type coach_type,
    total_seats BIGINT,
    booked_seats BIGINT,
    available_seats BIGINT
)
LANGUAGE plpgsql
AS $$ 
BEGIN 
    RETURN QUERY 
    SELECT c.coachtype,
           COUNT(s.id)::BIGINT as total_seats,
           COUNT(bi.seatId)::BIGINT as booked_seats,
           (COUNT(s.id) - COUNT(bi.seatId))::BIGINT as available_seats
    FROM train t 
    JOIN coach c ON t.id = c.trainId
    JOIN seat s ON c.id = s.coachId
    LEFT JOIN (
        SELECT DISTINCT bi.seatId
        FROM booking b
        JOIN bookingItem bi ON b.id = bi.bookingId
        WHERE b.trainId = p_train_id
          AND b.travelDate = p_travel_date
          AND b.status IN ('CONFIRMED', 'PENDING')
    ) bi ON s.id = bi.seatId
    WHERE t.id = p_train_id
    GROUP BY c.coachtype
    ORDER BY c.coachtype;
END;
$$
`

type GetAvailableSeatsRow struct {
}

func (q *Queries) GetAvailableSeats(ctx context.Context) ([]GetAvailableSeatsRow, error) {
	rows, err := q.db.Query(ctx, getAvailableSeats)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetAvailableSeatsRow{}
	for rows.Next() {
		var i GetAvailableSeatsRow
		if err := rows.Scan(); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getAvailableSeatsExecute = `-- name: GetAvailableSeatsExecute :many
SELECT  FROM get_available_seats($1, $2)
`

type GetAvailableSeatsExecuteParams struct {
	GetAvailableSeats   interface{} `json:"get_available_seats"`
	GetAvailableSeats_2 interface{} `json:"get_available_seats_2"`
}

type GetAvailableSeatsExecuteRow struct {
}

func (q *Queries) GetAvailableSeatsExecute(ctx context.Context, arg GetAvailableSeatsExecuteParams) ([]GetAvailableSeatsExecuteRow, error) {
	rows, err := q.db.Query(ctx, getAvailableSeatsExecute, arg.GetAvailableSeats, arg.GetAvailableSeats_2)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetAvailableSeatsExecuteRow{}
	for rows.Next() {
		var i GetAvailableSeatsExecuteRow
		if err := rows.Scan(); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getCoachesByTrain = `-- name: GetCoachesByTrain :many
SELECT id, trainid, coachtype, coachnumber FROM coach WHERE trainId = $1
`

func (q *Queries) GetCoachesByTrain(ctx context.Context, trainid pgtype.Int4) ([]Coach, error) {
	rows, err := q.db.Query(ctx, getCoachesByTrain, trainid)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Coach{}
	for rows.Next() {
		var i Coach
		if err := rows.Scan(
			&i.ID,
			&i.Trainid,
			&i.Coachtype,
			&i.Coachnumber,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getSeatsByCoach = `-- name: GetSeatsByCoach :many
SELECT id, coachid, seatno, berth FROM seat WHERE coachId = $1
`

func (q *Queries) GetSeatsByCoach(ctx context.Context, coachid pgtype.Int4) ([]Seat, error) {
	rows, err := q.db.Query(ctx, getSeatsByCoach, coachid)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Seat{}
	for rows.Next() {
		var i Seat
		if err := rows.Scan(
			&i.ID,
			&i.Coachid,
			&i.Seatno,
			&i.Berth,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getSeatsByTrain = `-- name: GetSeatsByTrain :many
SELECT s.id, s.coachid, s.seatno, s.berth
FROM seat s 
JOIN coach c ON s.coachId = c.id
WHERE c.trainId = $1
`

func (q *Queries) GetSeatsByTrain(ctx context.Context, trainid pgtype.Int4) ([]Seat, error) {
	rows, err := q.db.Query(ctx, getSeatsByTrain, trainid)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Seat{}
	for rows.Next() {
		var i Seat
		if err := rows.Scan(
			&i.ID,
			&i.Coachid,
			&i.Seatno,
			&i.Berth,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getTrainById = `-- name: GetTrainById :one
SELECT id, trainnumber, trainname, source, destination FROM train
WHERE id = $1
`

func (q *Queries) GetTrainById(ctx context.Context, id int32) (Train, error) {
	row := q.db.QueryRow(ctx, getTrainById, id)
	var i Train
	err := row.Scan(
		&i.ID,
		&i.Trainnumber,
		&i.Trainname,
		&i.Source,
		&i.Destination,
	)
	return i, err
}

const getTrainScheduleByDay = `-- name: GetTrainScheduleByDay :one
SELECT id, trainid, day, arrivaltime, departuretime FROM trainSchedule
WHERE trainId = $1
`

func (q *Queries) GetTrainScheduleByDay(ctx context.Context, trainid pgtype.Int4) (Trainschedule, error) {
	row := q.db.QueryRow(ctx, getTrainScheduleByDay, trainid)
	var i Trainschedule
	err := row.Scan(
		&i.ID,
		&i.Trainid,
		&i.Day,
		&i.Arrivaltime,
		&i.Departuretime,
	)
	return i, err
}

const validateSchedule = `-- name: ValidateSchedule :one
SELECT count(*)
FROM trainSchedule ts
WHERE ts.trainId = $1 
AND (ts.arrivaltime AT TIME ZONE 'UTC')::date = $2::date
`

type ValidateScheduleParams struct {
	Trainid pgtype.Int4 `json:"trainid"`
	Column2 pgtype.Date `json:"column_2"`
}

func (q *Queries) ValidateSchedule(ctx context.Context, arg ValidateScheduleParams) (int64, error) {
	row := q.db.QueryRow(ctx, validateSchedule, arg.Trainid, arg.Column2)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const validateSeatsBelongToTrain = `-- name: ValidateSeatsBelongToTrain :one
SELECT COUNT(*) = $1::int as all_seat_belong,
 count(*)::int as seat_found,
 $1 - COUNT(*) as seats_not_found
 FROM seat s 
 JOIN coach c on s.coachId = c.id
 WHERE s.id = ANY($2::int[])
  AND c.trainId = $3
`

type ValidateSeatsBelongToTrainParams struct {
	Column1 int32       `json:"column_1"`
	Column2 []int32     `json:"column_2"`
	Trainid pgtype.Int4 `json:"trainid"`
}

type ValidateSeatsBelongToTrainRow struct {
	AllSeatBelong bool  `json:"all_seat_belong"`
	SeatFound     int32 `json:"seat_found"`
	SeatsNotFound int   `json:"seats_not_found"`
}

func (q *Queries) ValidateSeatsBelongToTrain(ctx context.Context, arg ValidateSeatsBelongToTrainParams) (ValidateSeatsBelongToTrainRow, error) {
	row := q.db.QueryRow(ctx, validateSeatsBelongToTrain, arg.Column1, arg.Column2, arg.Trainid)
	var i ValidateSeatsBelongToTrainRow
	err := row.Scan(&i.AllSeatBelong, &i.SeatFound, &i.SeatsNotFound)
	return i, err
}

const validateTrain = `-- name: ValidateTrain :one
SELECT COUNT(*)
FROM train WHERE id = $1
`

func (q *Queries) ValidateTrain(ctx context.Context, id int32) (int64, error) {
	row := q.db.QueryRow(ctx, validateTrain, id)
	var count int64
	err := row.Scan(&count)
	return count, err
}
